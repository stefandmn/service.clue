# -*- coding: utf-8 -*-

import time
import datetime
import functools
import threading
import CommonFunctions as common

import xbmc
import xbmcaddon

true	= True
false	= False
null	= None

videolibScript		= "RunScript(service.clue, videolibupdate)"
musiclibScript		= "RunScript(service.clue, musiclibupdate)"
sysupdateScript		= "RunScript(service.clue, systemupdate)"
backupScript		= "RunScript(script.backuprestore, mode=backup)"


def runBuiltinFunction(function):
	common.debug("Starting builtin function: %s" %(function), "Scheduler")
	xbmc.executebuiltin("%s" % function)


class SchedulerManager():
	monitor = None

	def __init__(self, *args, **kwargs):
		self.addon = xbmcaddon.Addon()
		self.jobs = [ "videolib", "musiclib", "backup", "system", "custom1", "custom2", "custom3", "custom4", "custom5" ]
		self.schedule = Scheduler()
		self.monitor = SchedulerSettingsMonitor(updateSettingsMethod = self.setup)
		self.setup()


	def onInit(self):
		self.start()


	def setup(self):
		self.schedule.removeAll()
		self.load()


	def load(self):
		common.debug("Loading setting..", "Scheduler")
		weekdays = [ "null", 'monday', "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday" ]
		for jobname in self.jobs:
			jobconfig = {"enabled": eval(self.addon.getSetting(jobname)),
						"cycle": int(self.addon.getSetting(jobname + "_cycle")), # cycles: Weekly(0), Daily(1), Hourly(2), Minutes(3)
						"script": self.addon.getSetting(jobname + "_script"),
						"day": int(self.addon.getSetting(jobname + "_day")),
						"time": self.addon.getSetting(jobname + "_time"),
						"interval": int(self.addon.getSetting(jobname + "_interval")) }
			if jobname == "backup":
				jobconfig["script"] = backupScript
			elif jobname == "system":
				jobconfig["script"] = sysupdateScript
			elif jobname == "videolib":
				jobconfig["script"] = videolibScript
			elif jobname == "musiclib":
				jobconfig["script"] = musiclibScript
			if jobconfig["day"] > 0:
				jobconfig["day"] = weekdays[jobconfig["day"]]
			# Create jobs and schedule them for execution
			if jobconfig["enabled"]:
				job = None
				if jobconfig["cycle"] == 0:
					job = self.schedule.newJob(jobname).every(jobconfig["interval"]).weeks.weekday(jobconfig["day"]).at(jobconfig["time"])
				elif jobconfig["cycle"] == 1:
					job = self.schedule.newJob(jobname).every(jobconfig["interval"]).days.at(jobconfig["time"])
				elif jobconfig["cycle"] == 2:
					job = self.schedule.newJob(jobname).every(jobconfig["interval"]).hours
				elif jobconfig["cycle"] == 3:
					job = self.schedule.newJob(jobname).every(jobconfig["interval"]).minutes
				if job is None:
					common.error("Error creating job based on configuration: %s" %jobname, "Scheduler")
				else:
					if not jobconfig["script"]:
						common.error("Job '%s' is removed because no script has been configured to run" %jobname, "Scheduler")
						self.schedule.remove(job)
					else:
						job.doScript(jobconfig["script"])
						common.debug("Creating job: %s" %str(job), "Scheduler")
			else:
				common.debug("Job '%s' is not enabled" %jobname, "Scheduler")


	def start(self):
		while (not xbmc.abortRequested):
			self.schedule.run()
			xbmc.sleep(1000)


class SchedulerSettingsMonitor(xbmc.Monitor):
	updateSettingsMethod = None

	def __init__(self,*args, **kwargs):
		xbmc.Monitor.__init__(self)
		self.updateSettingsMethod = kwargs['updateSettingsMethod']


	def onSettingsChanged(self):
		self.updateSettingsMethod()



class Scheduler(object):

	def __init__(self):
		self.jobs = []


	def run(self):
		"""Run all jobs that are scheduled to run.

		Please note that it is *intended behavior that tick() does not
		run missed jobs*. For example, if you've registered a job that
		should run every minute and you only call tick() in one hour
		increments then your job won't be run 60 times in between but
		only once.
		"""
		runnableJobs = (job for job in self.jobs if job.isReady)
		for job in sorted(runnableJobs):
			job.run()


	def runAllNow(self, delaySeconds=0):
		"""Run all jobs regardless if they are scheduled to run or not.

		A delay of `delay` seconds is added between each job. This helps
		distribute system load generated by the jobs more evenly
		over time."""
		for job in self.jobs:
			job.run()
			time.sleep(delaySeconds)


	def removeAll(self):
		"""Deletes all scheduled jobs."""
		del self.jobs[:]


	def remove(self, job):
		"""Delete a scheduled job."""
		try:
			self.jobs.remove(job)
		except ValueError:
			pass


	@property
	def NextRun(self):
		"""Datetime when the next job should run."""
		if not self.jobs:
			return None
		return min(self.jobs).NextRun


	@property
	def idle(self):
		"""Number of seconds until `next_run`."""
		return (self.NextRun - datetime.datetime.now()).total_seconds()


	def newJob(self, code, interval=1):
		"""Schedule a new periodic job."""
		job = Job(code, interval)
		self.jobs.append(job)
		return job


	def getJob(self, code):
		selectedJob = None
		for job in self.jobs:
			if job.code == code:
				selectedJob = job
				break
		return selectedJob


class Job(object):
	"""A periodic job as used by `Scheduler`."""

	def __init__(self, code, interval=1):
		self.code = code # job code
		self.interval = interval  # pause interval * unit between runs
		self.function = None  # the job job_func to run
		self.unit = None  # time units, e.g. 'minutes', 'hours', ...
		self.atTime = None  # optional time at which this job runs
		self.lastRun = None  # datetime of the last run
		self.nextRun = None  # datetime of the next run
		self.period = None  # timedelta between runs, only valid for
		self.startDay = None  # Specific day of the week to start on


	def __lt__(self, other):
		"""PeriodicJobs are sortable based on the scheduled time they run next."""
		return self.nextRun < other.NextRun


	def __repr__(self):
		def format_time(t):
			return t.strftime("%Y-%m-%d %H:%M:%S") if t else '[never]'

		timestats = 'Last run: %s, Next run: %s' % (format_time(self.lastRun), format_time(self.nextRun))
		jobFunctionName = self.function.__name__
		args = [repr(x) for x in self.function.args]
		kwargs = ['%s=%s' % (k, repr(v))
			for k, v in self.function.keywords.items()]
		callRepresentation = jobFunctionName + '(' + ', '.join(args + kwargs) + ')'

		if self.atTime is not None:
			return '%s - Runs every %s %s at %s, do %s, %s' % (self.code.capitalize(), self.interval,
				self.unit[:-1] if self.interval == 1 else self.unit,
				self.atTime, callRepresentation, timestats)
		else:
			return '%s - Runs every %s %s, do %s, %s' % (self.code.capitalize(), self.interval,
				self.unit[:-1] if self.interval == 1 else self.unit,
				callRepresentation, timestats)


	@property
	def second(self):
		assert self.interval == 1
		return self.seconds


	@property
	def seconds(self):
		self.unit = 'seconds'
		return self

	@property
	def minute(self):
		assert self.interval == 1
		return self.minutes


	@property
	def minutes(self):
		self.unit = 'minutes'
		return self


	@property
	def hour(self):
		assert self.interval == 1
		return self.hours


	@property
	def hours(self):
		self.unit = 'hours'
		return self


	@property
	def day(self):
		assert self.interval == 1
		return self.days


	@property
	def days(self):
		self.unit = 'days'
		return self


	@property
	def week(self):
		assert self.interval == 1
		return self.weeks


	def weekday(self, day):
		assert self.interval == 1
		self.startDay = day
		return self.weeks


	@property
	def sunday(self):
		assert self.interval == 1
		self.startDay = 'sunday'
		return self.weeks


	@property
	def monday(self):
		assert self.interval == 1
		self.startDay = 'monday'
		return self.weeks


	@property
	def tuesday(self):
		assert self.interval == 1
		self.startDay = 'tuesday'
		return self.weeks


	@property
	def wednesday(self):
		assert self.interval == 1
		self.startDay = 'wednesday'
		return self.weeks


	@property
	def thursday(self):
		assert self.interval == 1
		self.startDay = 'thursday'
		return self.weeks


	@property
	def friday(self):
		assert self.interval == 1
		self.startDay = 'friday'
		return self.weeks


	@property
	def saturday(self):
		assert self.interval == 1
		self.startDay = 'saturday'
		return self.weeks


	@property
	def weeks(self):
		self.unit = 'weeks'
		return self


	def every(self, interval):
		self.interval = interval
		return self


	def at(self, timeStr):
		"""Schedule the job every day at a specific time.

		Calling this is only valid for jobs scheduled to run every
		N day(s).
		"""
		assert self.unit in ('days', 'hours') or self.startDay
		hour, minute = [t for t in timeStr.split(':')]
		minute = int(minute)
		if self.unit == 'days' or self.startDay:
			hour = int(hour)
			assert 0 <= hour <= 23
		elif self.unit == 'hours':
			hour = 0
		assert 0 <= minute <= 59
		self.atTime = datetime.time(hour, minute)
		return self


	def doCode(self, function, *args, **kwargs):
		"""Specifies the function that should be called every time the
		job runs.

		Any additional arguments are passed on to job_func when
		the job runs.
		"""
		self.function = functools.partial(function, *args, **kwargs)
		functools.update_wrapper(self.function, function)
		self._setNextRun()
		return self


	def doScript(self, function):
		self.doCode(runBuiltinFunction, function)
		return self

	@property
	def isReady(self):
		"""True if the job should be run now."""
		return datetime.datetime.now() >= self.nextRun


	def run(self):
		"""Run the job and immediately reschedule it."""
		runner=threading.Thread(target=self._run)
		runner.setDaemon(True)
		runner.start()


	def _run(self):
		"""Run the job and immediately reschedule it."""
		self.function()
		self.lastRun = datetime.datetime.now()
		self._setNextRun()
		common.debug("Run job: %s" %str(self), "Scheduler")


	def _setNextRun(self):
		"""Compute the instant when this job should run next."""
		assert self.unit in ('seconds', 'minutes', 'hours', 'days', 'weeks')
		self.period = datetime.timedelta(**{self.unit: self.interval})
		self.nextRun = datetime.datetime.now() + self.period
		if self.startDay is not None:
			assert self.unit == 'weeks'
			weekdays = ('monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday')
			assert self.startDay in weekdays
			weekday = weekdays.index(self.startDay)
			days_ahead = weekday - self.nextRun.weekday()
			if days_ahead <= 0:  # Target day already happened this week
				days_ahead += 7
			self.nextRun += datetime.timedelta(days_ahead) - self.period
		if self.atTime is not None:
			assert self.unit in ('days', 'hours') or self.startDay is not None
			kwargs = { 'minute': self.atTime.minute, 'second': self.atTime.second, 'microsecond': 0 }
			if self.unit == 'days' or self.startDay is not None:
				kwargs['hour'] = self.atTime.hour
			self.nextRun = self.nextRun.replace(**kwargs)
			# If we are running for the first time, make sure we run at the specified time *today* (or *this hour*) as well
			if not self.lastRun:
				now = datetime.datetime.now()
				if self.unit == 'days' and self.atTime > now.time():
					self.nextRun = self.nextRun - datetime.timedelta(days=1)
				elif self.unit == 'hours' and self.atTime.minute > now.minute:
					self.nextRun = self.nextRun - datetime.timedelta(hours=1)
		if self.startDay is not None and self.atTime is not None:
			# Let's see if we will still make that time we specified today
			if (self.nextRun - datetime.datetime.now()).days >= 7:
				self.nextRun -= self.period
