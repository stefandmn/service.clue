# -*- coding: utf-8 -*-

import sys
import time
import datetime
import threading
import Commons as commons
if hasattr(sys.modules["__main__"], "xbmc"):
	xbmc = sys.modules["__main__"].xbmc
else:
	import xbmc


class SchedulerManager():
	monitor = None
	weekdays = ['monday', "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]
	jobnames = [ "videolib", "musiclib", "backup", "system", "custom1", "custom2", "custom3", "custom4", "custom5", "custom6"]

	def __init__(self, *args, **kwargs):
		self.monitor = SettingsMonitor(updateSettingsMethod=self.setup)
		self.scheduler = Scheduler()
		self.setup()

	def onInit(self):
		self.start()

	def setup(self):
		self.scheduler.removeAll()
		self.load()

	def load(self):
		commons.debug("Loading scheduler setting..", "Scheduler")
		for jobname in self.jobnames:
			job = None
			cfg = {
					"enabled": commons.setting(jobname),
					"cycle": commons.setting(jobname + "_cycle"), # cycles: Weekly(0), Daily(1), Hourly(2), Minutes(3)
					"script": commons.setting(jobname + "_script"),
					"day": commons.setting(jobname + "_day"),
					"time": commons.setting(jobname + "_time"),
					"interval": commons.setting(jobname + "_interval")}
			cfg["day"] = self.weekdays[cfg["day"]] if cfg["day"] >= 0 else -1
			# Adapt job script
			if jobname == "backup":
				cfg["script"] = "RunScript(script.backuprestore, mode=backup)"
			elif not jobname.lower().startswith("runscript"):
				cfg["script"] = "RunScript(%s, %s)" %(commons.AddonId(), jobname)
			# Create job instance
			if cfg["enabled"]:
				if cfg["cycle"] == 0:
					job = self.scheduler.newJob(jobname).every(cfg["interval"]).weeks.weekday(cfg["day"]).at(cfg["time"])
				elif cfg["cycle"] == 1:
					job = self.scheduler.newJob(jobname).every(cfg["interval"]).days.at(cfg["time"])
				elif cfg["cycle"] == 2:
					job = self.scheduler.newJob(jobname).every(cfg["interval"]).hours
				elif cfg["cycle"] == 3:
					job = self.scheduler.newJob(jobname).every(cfg["interval"]).minutes
				# Apply job script
				if job is not None and cfg["script"]:
					job.setScript(cfg["script"])
					commons.debug("Creating job: %s" %str(job), "Scheduler")
				elif job is not None and not cfg["script"]:
					commons.error("Job '%s' is removed because no script has been configured to run" %jobname, "Scheduler")
					self.scheduler.remove(job)
				else:
					commons.error("Error creating job based on configuration: %s" %jobname, "Scheduler")
			else:
				commons.debug("Job '%s' is not enabled" %jobname, "Scheduler")

	def start(self):
		while (not xbmc.abortRequested):
			self.scheduler.run()
			xbmc.sleep(1000)


class SettingsMonitor(xbmc.Monitor):
	updateSettingsMethod = None

	def __init__(self,*args, **kwargs):
		xbmc.Monitor.__init__(self)
		self.updateSettingsMethod = kwargs['updateSettingsMethod']

	def onSettingsChanged(self):
		commons.debug("Settings have been updated and will trigger re-loading of scheduler jobs", "SettingsMonitor")
		self.updateSettingsMethod()


class Scheduler(object):

	def __init__(self):
		self.jobs = []

	def run(self):
		"""
		Run all jobs that are scheduled to run.
		Please note that it is *intended behavior that tick() does not
		run missed jobs*. For example, if you've registered a job that
		should run every minute and you only call tick() in one hour
		increments then your job won't be run 60 times in between but
		only once.
		"""
		runnableJobs = (job for job in self.jobs if job.isReady)
		for job in sorted(runnableJobs):
			job.run()

	def runAllNow(self, delaySeconds=0):
		"""
		Run all jobs regardless if they are scheduled to run or not.
		A delay of `delay` seconds is added between each job. This helps
		distribute system load generated by the jobs more evenly
		over time.
		"""
		for job in self.jobs:
			job.run()
			time.sleep(delaySeconds)

	def removeAll(self):
		"""
		eletes all scheduled jobs.
		"""
		del self.jobs[:]

	def remove(self, job):
		"""
		Delete a scheduled job.
		"""
		try:
			self.jobs.remove(job)
		except ValueError:
			pass

	@property
	def NextRun(self):
		"""
		Datetime when the next job should run.
		"""
		if not self.jobs:
			return None
		return min(self.jobs).NextRun

	@property
	def idle(self):
		"""
		Number of seconds until `next_run`.
		"""
		return (self.NextRun - datetime.datetime.now()).total_seconds()

	def newJob(self, code, interval=1):
		"""
		Schedule a new periodic job.
		"""
		job = Job(code, interval)
		self.jobs.append(job)
		return job

	def getJob(self, code):
		selectedJob = None
		for job in self.jobs:
			if job.code == code:
				selectedJob = job
				break
		return selectedJob


class Job(object):
	"""
	A periodic job as used by `Scheduler`.
	"""

	def __init__(self, code, interval=1):
		self.code = code # job code
		self.interval = interval  # pause interval * unit between runs
		self.script = None  # the job job_func to run
		self.unit = None  # time units, e.g. 'minutes', 'hours', ...
		self.atTime = None  # optional time at which this job runs
		self.lastRun = None  # datetime of the last run
		self.nextRun = None  # datetime of the next run
		self.period = None  # timedelta between runs, only valid for
		self.startDay = None  # Specific day of the week to start on

	def __lt__(self, other):
		"""
		PeriodicJobs are sortable based on the scheduled time they run next.
		"""
		return self.nextRun < other.nextRun

	def __repr__(self):
		def format_time(t):
			return t.strftime("%Y-%m-%d %H:%M:%S") if t else '[never]'
		timestats = 'Last run: %s, Next run: %s' % (format_time(self.lastRun), format_time(self.nextRun))
		if self.atTime is not None:
			return '%s - Runs every %s %s at %s, do %s, %s' % (self.code.capitalize(), self.interval,
				self.unit[:-1] if self.interval == 1 else self.unit, self.atTime, self.script, timestats)
		else:
			return '%s - Runs every %s %s, do %s, %s' % (self.code.capitalize(), self.interval,
				self.unit[:-1] if self.interval == 1 else self.unit, self.script, timestats)

	@property
	def second(self):
		assert self.interval == 1
		return self.seconds

	@property
	def seconds(self):
		self.unit = 'seconds'
		return self

	@property
	def minute(self):
		assert self.interval == 1
		return self.minutes

	@property
	def minutes(self):
		self.unit = 'minutes'
		return self

	@property
	def hour(self):
		assert self.interval == 1
		return self.hours

	@property
	def hours(self):
		self.unit = 'hours'
		return self

	@property
	def day(self):
		assert self.interval == 1
		return self.days

	@property
	def days(self):
		self.unit = 'days'
		return self

	@property
	def week(self):
		assert self.interval == 1
		return self.weeks

	def weekday(self, day):
		assert self.interval == 1
		self.startDay = day
		return self.weeks

	@property
	def sunday(self):
		assert self.interval == 1
		self.startDay = 'sunday'
		return self.weeks

	@property
	def monday(self):
		assert self.interval == 1
		self.startDay = 'monday'
		return self.weeks

	@property
	def tuesday(self):
		assert self.interval == 1
		self.startDay = 'tuesday'
		return self.weeks

	@property
	def wednesday(self):
		assert self.interval == 1
		self.startDay = 'wednesday'
		return self.weeks

	@property
	def thursday(self):
		assert self.interval == 1
		self.startDay = 'thursday'
		return self.weeks

	@property
	def friday(self):
		assert self.interval == 1
		self.startDay = 'friday'
		return self.weeks

	@property
	def saturday(self):
		assert self.interval == 1
		self.startDay = 'saturday'
		return self.weeks

	@property
	def weeks(self):
		self.unit = 'weeks'
		return self

	def every(self, interval):
		self.interval = interval
		return self

	def at(self, timeStr):
		"""
		Schedule the job every day at a specific time.
		Calling this is only valid for jobs scheduled to run every
		N day(s).
		"""
		assert self.unit in ('days', 'hours') or self.startDay
		hour, minute = [t for t in timeStr.split(':')]
		minute = int(minute)
		if self.unit == 'days' or self.startDay:
			hour = int(hour)
			assert 0 <= hour <= 23
		elif self.unit == 'hours':
			hour = 0
		assert 0 <= minute <= 59
		self.atTime = datetime.time(hour, minute)
		return self

	def setScript(self, script):
		self.script = script
		self._setNextRun()
		return self

	def run(self):
		"""
		Run the job and immediately reschedule it.
		"""
		runner=threading.Thread(target=self._run)
		runner.setDaemon(True)
		runner.start()

	def _run(self):
		"""
		Run the job and immediately reschedule it.
		"""
		commons.debug("Starting job: %s" %str(self), "Scheduler")
		xbmc.executebuiltin(self.script)
		self.lastRun = datetime.datetime.now()
		self._setNextRun()
		commons.debug("Finishing job: %s" %str(self), "Scheduler")

	@property
	def isReady(self):
		"""
		True if the job should be run now.
		"""
		return datetime.datetime.now() >= self.nextRun

	def _setNextRun(self):
		"""
		Compute the instant when this job should run next.
		"""
		assert self.unit in ('seconds', 'minutes', 'hours', 'days', 'weeks')
		self.period = datetime.timedelta(**{self.unit: self.interval})
		self.nextRun = datetime.datetime.now() + self.period
		if self.startDay is not None:
			assert self.unit == 'weeks'
			weekdays = ('monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday')
			assert self.startDay in weekdays
			weekday = weekdays.index(self.startDay)
			days_ahead = weekday - self.nextRun.weekday()
			if days_ahead <= 0:  # Target day already happened this week
				days_ahead += 7
			self.nextRun += datetime.timedelta(days_ahead) - self.period
		if self.atTime is not None:
			assert self.unit in ('days', 'hours') or self.startDay is not None
			kwargs = { 'minute': self.atTime.minute, 'second': self.atTime.second, 'microsecond': 0 }
			if self.unit == 'days' or self.startDay is not None:
				kwargs['hour'] = self.atTime.hour
			self.nextRun = self.nextRun.replace(**kwargs)
			# If we are running for the first time, make sure we run at the specified time *today* (or *this hour*) as well
			if not self.lastRun:
				now = datetime.datetime.now()
				if self.unit == 'days' and self.atTime > now.time():
					self.nextRun = self.nextRun - datetime.timedelta(days=1)
				elif self.unit == 'hours' and self.atTime.minute > now.minute:
					self.nextRun = self.nextRun - datetime.timedelta(hours=1)
		if self.startDay is not None and self.atTime is not None:
			# Let's see if we will still make that time we specified today
			if (self.nextRun - datetime.datetime.now()).days >= 7:
				self.nextRun -= self.period
