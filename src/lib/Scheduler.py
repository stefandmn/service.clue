# -*- coding: utf-8 -*-

import sys
import time
import inspect
import datetime
import threading
import Commons as commons
if hasattr(sys.modules["__main__"], "xbmc"):
	xbmc = sys.modules["__main__"].xbmc
else:
	import xbmc

class Scheduler(object):

	def __init__(self):
		self.jobs = []

	def run(self):
		"""
		Run all jobs that are scheduled to run.
		Please note that it is *intended behavior that tick() does not
		run missed jobs*. For example, if you've registered a job that
		should run every minute and you only call tick() in one hour
		increments then your job won't be run 60 times in between but
		only once.
		"""
		runnableJobs = (job for job in self.jobs if job.isReady)
		for job in sorted(runnableJobs):
			job.run()

	def runAllNow(self, delaySeconds=0):
		"""
		Run all jobs regardless if they are scheduled to run or not.
		A delay of `delay` seconds is added between each job. This helps
		distribute system load generated by the jobs more evenly
		over time.
		"""
		for job in self.jobs:
			job.run()
			time.sleep(delaySeconds)

	def removeAll(self):
		"""
		eletes all scheduled jobs.
		"""
		del self.jobs[:]

	def remove(self, job):
		"""
		Delete a scheduled job.
		"""
		try:
			self.jobs.remove(job)
		except ValueError:
			pass

	@property
	def NextRun(self):
		"""
		Datetime when the next job should run.
		"""
		if not self.jobs:
			return None
		return min(self.jobs).NextRun

	@property
	def idle(self):
		"""
		Number of seconds until `next_run`.
		"""
		return (self.NextRun - datetime.datetime.now()).total_seconds()

	def newJob(self, code, interval=1):
		"""
		Schedule a new periodic job.
		"""
		job = Job(code, interval)
		self.jobs.append(job)
		return job

	def getJob(self, code):
		selectedJob = None
		for job in self.jobs:
			if job.code == code:
				selectedJob = job
				break
		return selectedJob


class Job(object):
	"""
	A periodic job as used by `Scheduler`.
	"""

	def __init__(self, code, interval=1):
		self.code = code # job code
		self.interval = interval  # pause interval * unit between runs
		self.script = None  # the job job_func to run
		self.unit = None  # time units, e.g. 'minutes', 'hours', ...
		self.atTime = None  # optional time at which this job runs
		self.lastRun = None  # datetime of the last run
		self.nextRun = None  # datetime of the next run
		self.period = None  # timedelta between runs, only valid for
		self.startDay = None  # Specific day of the week to start on

	def __lt__(self, other):
		"""
		PeriodicJobs are sortable based on the scheduled time they run next.
		"""
		return self.nextRun < other.nextRun

	def __repr__(self):
		def format_time(t):
			return t.strftime("%Y-%m-%d %H:%M:%S") if t else '[never]'
		timestats = 'Last run: %s, Next run: %s' % (format_time(self.lastRun), format_time(self.nextRun))
		if self.atTime is not None:
			return '%s - Runs every %s %s at %s, do %s, %s' % (self.code.capitalize(), self.interval,
				self.unit[:-1] if self.interval == 1 else self.unit, self.atTime, str(self.script), timestats)
		else:
			return '%s - Runs every %s %s, do %s, %s' % (self.code.capitalize(), self.interval,
				self.unit[:-1] if self.interval == 1 else self.unit, str(self.script), timestats)

	@property
	def second(self):
		assert self.interval == 1
		return self.seconds

	@property
	def seconds(self):
		self.unit = 'seconds'
		return self

	@property
	def minute(self):
		assert self.interval == 1
		return self.minutes

	@property
	def minutes(self):
		self.unit = 'minutes'
		return self

	@property
	def hour(self):
		assert self.interval == 1
		return self.hours

	@property
	def hours(self):
		self.unit = 'hours'
		return self

	@property
	def day(self):
		assert self.interval == 1
		return self.days

	@property
	def days(self):
		self.unit = 'days'
		return self

	@property
	def week(self):
		assert self.interval == 1
		return self.weeks

	def weekday(self, day):
		assert self.interval == 1
		self.startDay = day
		return self.weeks

	@property
	def sunday(self):
		assert self.interval == 1
		self.startDay = 'sunday'
		return self.weeks

	@property
	def monday(self):
		assert self.interval == 1
		self.startDay = 'monday'
		return self.weeks

	@property
	def tuesday(self):
		assert self.interval == 1
		self.startDay = 'tuesday'
		return self.weeks

	@property
	def wednesday(self):
		assert self.interval == 1
		self.startDay = 'wednesday'
		return self.weeks

	@property
	def thursday(self):
		assert self.interval == 1
		self.startDay = 'thursday'
		return self.weeks

	@property
	def friday(self):
		assert self.interval == 1
		self.startDay = 'friday'
		return self.weeks

	@property
	def saturday(self):
		assert self.interval == 1
		self.startDay = 'saturday'
		return self.weeks

	@property
	def weeks(self):
		self.unit = 'weeks'
		return self

	def every(self, interval):
		self.interval = interval
		return self

	def at(self, timeStr):
		"""
		Schedule the job every day at a specific time.
		Calling this is only valid for jobs scheduled to run every
		N day(s).
		"""
		assert self.unit in ('days', 'hours') or self.startDay
		hour, minute = [t for t in timeStr.split(':')]
		minute = int(minute)
		if self.unit == 'days' or self.startDay:
			hour = int(hour)
			assert 0 <= hour <= 23
		elif self.unit == 'hours':
			hour = 0
		assert 0 <= minute <= 59
		self.atTime = datetime.time(hour, minute)
		return self

	def setScript(self, script):
		self.script = script
		self._setNextRun()
		return self

	def run(self):
		"""
		Run the job and immediately reschedule it.
		"""
		runner=threading.Thread(target=self._run)
		runner.setDaemon(True)
		runner.start()

	def _run(self):
		"""
		Run the job and immediately reschedule it.
		"""
		commons.debug("Starting job: %s" %str(self), "Scheduler")
		if isinstance(self.script, str) and self.script.strip().lower().startswith("runscript"):
			xbmc.executebuiltin(self.script)
		if isinstance(self.script, str) and self.script.strip().lower().startswith("/"):
			commons.procexec(self.script)
		elif inspect.isclass(self.script):
			if isinstance(self.script, threading.Thread):
				self.script.start()
			elif "start" in dir(self.script):
				self.script.start()
			elif "run" in dir(self.script):
				self.script.run()
		elif hasattr(self.script, '__call__'):
			self.script()
		self.lastRun = datetime.datetime.now()
		self._setNextRun()
		commons.debug("Finishing job: %s" %str(self), "Scheduler")

	@property
	def isReady(self):
		"""
		True if the job should be run now.
		"""
		return datetime.datetime.now() >= self.nextRun

	def _setNextRun(self):
		"""
		Compute the instant when this job should run next.
		"""
		assert self.unit in ('seconds', 'minutes', 'hours', 'days', 'weeks')
		self.period = datetime.timedelta(**{self.unit: self.interval})
		self.nextRun = datetime.datetime.now() + self.period
		if self.startDay is not None:
			assert self.unit == 'weeks'
			weekdays = ('monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday')
			assert self.startDay in weekdays
			weekday = weekdays.index(self.startDay)
			days_ahead = weekday - self.nextRun.weekday()
			if days_ahead <= 0:  # Target day already happened this week
				days_ahead += 7
			self.nextRun += datetime.timedelta(days_ahead) - self.period
		if self.atTime is not None:
			assert self.unit in ('days', 'hours') or self.startDay is not None
			kwargs = { 'minute': self.atTime.minute, 'second': self.atTime.second, 'microsecond': 0 }
			if self.unit == 'days' or self.startDay is not None:
				kwargs['hour'] = self.atTime.hour
			self.nextRun = self.nextRun.replace(**kwargs)
			# If we are running for the first time, make sure we run at the specified time *today* (or *this hour*) as well
			if not self.lastRun:
				now = datetime.datetime.now()
				if self.unit == 'days' and self.atTime > now.time():
					self.nextRun = self.nextRun - datetime.timedelta(days=1)
				elif self.unit == 'hours' and self.atTime.minute > now.minute:
					self.nextRun = self.nextRun - datetime.timedelta(hours=1)
		if self.startDay is not None and self.atTime is not None:
			# Let's see if we will still make that time we specified today
			if (self.nextRun - datetime.datetime.now()).days >= 7:
				self.nextRun -= self.period
