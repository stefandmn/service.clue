# -*- coding: utf-8 -*-

import sys
import time
import inspect
import commons
import datetime
import threading

if hasattr(sys.modules["__main__"], "xbmc"):
	xbmc = sys.modules["__main__"].xbmc
else:
	import xbmc



class Scheduler(object):

	def __init__(self):
		self.jobs = []


	def run(self):
		"""
		Run all jobs that are scheduled to run.
		Please note that it is *intended behavior that tick() does not
		run missed jobs*. For example, if you've registered a job that
		should run every minute and you only call tick() in one hour
		increments then your job won't be run 60 times in between but
		only once.
		"""
		runnableJobs = (job for job in self.jobs if job.isReady)
		for job in sorted(runnableJobs):
			job.run()


	def runAllNow(self, delaySeconds=0):
		"""
		Run all jobs regardless if they are scheduled to run or not.
		A delay of `delay` seconds is added between each job. This helps
		distribute system load generated by the jobs more evenly
		over time.
		"""
		for job in self.jobs:
			job.run()
			time.sleep(delaySeconds)


	def removeAll(self):
		"""
		Deletes all scheduled jobs.
		"""
		del self.jobs[:]


	def remove(self, job):
		"""
		Delete a scheduled job.
		"""
		try:
			self.jobs.remove(job)
		except ValueError:
			pass


	@property
	def NextRun(self):
		"""
		Datetime when the next job should run.
		"""
		if not self.jobs:
			return None
		return min(self.jobs).NextRun


	@property
	def idle(self):
		"""
		Number of seconds until `next_run`.
		"""
		return (self.NextRun - datetime.datetime.now()).total_seconds()


	def newJob(self, code, interval=1):
		"""
		Schedule a new periodic job.
		"""
		job = Job(code, interval)
		self.jobs.append(job)
		return job


	def getJob(self, code):
		selectedJob = None
		for job in self.jobs:
			if job.code == code:
				selectedJob = job
				break
		return selectedJob



class Job(object):
	"""
	A periodic job as used by `Scheduler`.
	"""

	def __init__(self, code, interval=1, type='script'):
		self.code = code # job code
		self.interval = interval  # pause interval * unit between runs
		self.script = None  # the job job_func to run
		self.type = type  # the job type to run: script, addon, plugin, command, process, json, object
		self.unit = None  # time units, e.g. 'minutes', 'hours', ...
		self.atTime = None  # optional time at which this job runs
		self.lastRun = None  # datetime of the last run
		self.nextRun = None  # datetime of the next run
		self.period = None  # timedelta between runs, only valid for
		self.startDay = None  # Specific day of the week to start on


	def __lt__(self, other):
		"""
		PeriodicJobs are sortable based on the scheduled time they run next.
		"""
		return self.nextRun < other.nextRun


	def __repr__(self):
		def format_time(t):
			return t.strftime("%Y-%m-%d %H:%M:%S") if t else '[never]'
		timestats = 'Last run: %s, Next run: %s' % (format_time(self.lastRun), format_time(self.nextRun))
		if self.atTime is not None:
			return '%s (%s) - Runs every %s %s at %s, do %s, %s' % (self.code.capitalize(), self.type, self.interval,
				self.unit[:-1] if self.interval == 1 else self.unit, self.atTime, self.scriptbytype, timestats)
		else:
			return '%s (%s)- Runs every %s %s, do %s, %s' % (self.code.capitalize(), self.type, self.interval,
				self.unit[:-1] if self.interval == 1 else self.unit, self.scriptbytype, timestats)


	@property
	def second(self):
		assert self.interval == 1
		return self.seconds


	@property
	def seconds(self):
		self.unit = 'seconds'
		return self


	@property
	def minute(self):
		assert self.interval == 1
		return self.minutes


	@property
	def minutes(self):
		self.unit = 'minutes'
		return self


	@property
	def hour(self):
		assert self.interval == 1
		return self.hours


	@property
	def hours(self):
		self.unit = 'hours'
		return self


	@property
	def day(self):
		assert self.interval == 1
		return self.days


	@property
	def days(self):
		self.unit = 'days'
		return self


	@property
	def week(self):
		assert self.interval == 1
		return self.weeks


	def weekday(self, day):
		assert self.interval == 1
		self.startDay = day
		return self.weeks


	@property
	def sunday(self):
		assert self.interval == 1
		self.startDay = 'sunday'
		return self.weeks


	@property
	def monday(self):
		assert self.interval == 1
		self.startDay = 'monday'
		return self.weeks


	@property
	def tuesday(self):
		assert self.interval == 1
		self.startDay = 'tuesday'
		return self.weeks


	@property
	def wednesday(self):
		assert self.interval == 1
		self.startDay = 'wednesday'
		return self.weeks


	@property
	def thursday(self):
		assert self.interval == 1
		self.startDay = 'thursday'
		return self.weeks


	@property
	def friday(self):
		assert self.interval == 1
		self.startDay = 'friday'
		return self.weeks


	@property
	def saturday(self):
		assert self.interval == 1
		self.startDay = 'saturday'
		return self.weeks


	@property
	def weeks(self):
		self.unit = 'weeks'
		return self


	def every(self, interval):
		self.interval = interval
		return self


	def at(self, timeStr):
		"""
		Schedule the job every day at a specific time.
		Calling this is only valid for jobs scheduled to run every
		N day(s).
		"""
		assert self.unit in ('days', 'hours') or self.startDay
		hour, minute = [t for t in timeStr.split(':')]
		minute = int(minute)
		if self.unit == 'days' or self.startDay:
			hour = int(hour)
			assert 0 <= hour <= 23
		elif self.unit == 'hours':
			hour = 0
		assert 0 <= minute <= 59
		self.atTime = datetime.time(hour, minute)
		return self


	def setScript(self, script):
		self.script = script
		self._setNextRun()
		return self


	def setType(self, type='script'):
		if type in ('script', 'addon', 'plugin', 'command', 'process', 'json'):
			self.type = type
		return self


	@property
	def scriptbytype(self):
		action = None
		if self.script is not None:
			if self.type is None or self.type == 'script':
				if self.script.strip().lower().startswith("runscript"):
					action = self.script
				else:
					action = "RunScript(" + self.script + ")"
			elif self.type == 'addon':
				if self.script.strip().lower().startswith("runaddon"):
					action = self.script
				else:
					action = "RunAddon(" + self.script + ")"
			elif self.type == 'plugin':
				if self.script.strip().lower().startswith("runplugin"):
					action = self.script
				else:
					action = "RunPlugin(" + self.script + ")"
			elif self.type == 'command':
				if self.script.strip().lower().startswith("runcommand"):
					action = self.script
				else:
					action = "RunCommand(" + self.script + ")"
			elif self.type == 'process':
				if self.script.strip().lower().startswith("runprocess"):
					action = self.script
				else:
					action = "RunProcess(" + self.script + ")"
			elif self.type == 'json':
				if self.script.strip().lower().startswith("runjson"):
					return self.script
				else:
					action = "RunJSON(" + self.script + ")"
			elif self.type == 'object':
				if self.script.strip().lower().startswith("callobject"):
					return self.script
				else:
					action = "CallObject(" + self.script + ")"
		return action


	def run(self):
		"""
		Run the job and immediately reschedule it.
		"""
		runner=threading.Thread(target=self._run)
		runner.setDaemon(True)
		runner.start()


	def _run(self):
		"""
		Run the job and immediately reschedule it.
		"""
		commons.debug("Starting job: %s" %str(self), "service.SchedulerJob")
		if self.script is not None:
			if self.type in ['script', 'addon', 'plugin']:
				addon = self.scriptbytype
				commons.debug("Executing addon: %s" %addon, "service.SchedulerJob")
				xbmc.executebuiltin(addon)
			elif str(self.type) == 'process':
				process = self.scriptbytype.strip()[len("runprocess"):].strip()[1:-1].strip()
				commons.debug("Executing process: %s" % process, "service.SchedulerJob")
				commons.procexec(process)
			elif str(self.type) == 'command':
				command = self.scriptbytype.strip()[len("runcommand"):].strip()[1:-1].strip()
				commons.debug("Executing command: %s" % command, "service.SchedulerJob")
				xbmc.executebuiltin(command)
			elif str(self.type) == 'json':
				call = self.scriptbytype.strip()[len("runjson"):].strip()[1:-1].strip()
				commons.debug("Executing json call: %s" %call, "service.SchedulerJob")
				xbmc.executeJSONRPC(call)
			elif str(self.type) == 'object':
				if isinstance(self.script, str):
					function = self.scriptbytype.strip()[len("callobject"):].strip()[1:-1].strip()
					commons.debug("Executing function: %s" %str(function), "service.SchedulerJob")
					eval(function)
				elif inspect.isclass(self.script):
					if isinstance(self.script, threading.Thread):
						commons.debug("Executing default method of runner object: %s" % str(self.script), "service.SchedulerJob")
						self.script.start()
					elif "start" in dir(self.script):
						commons.debug("Executing start method of runner object: %s" % str(self.script), "service.SchedulerJob")
						self.script.start()
					elif "run" in dir(self.script):
						commons.debug("Executing run method of runner object: %s" % str(self.script), "service.SchedulerJob")
						self.script.run()
				elif hasattr(self.script, '__call__'):
					commons.debug("Executing generic object: %s" % str(self.script), "service.SchedulerJob")
					self.script()
		self.lastRun = datetime.datetime.now()
		self._setNextRun()
		commons.debug("Finishing job: %s" %str(self), "service.SchedulerJob")


	@property
	def isReady(self):
		"""
		True if the job should be run now.
		"""
		return datetime.datetime.now() >= self.nextRun


	def _setNextRun(self):
		"""
		Compute the instant when this job should run next.
		"""
		assert self.unit in ('seconds', 'minutes', 'hours', 'days', 'weeks')
		self.period = datetime.timedelta(**{self.unit: self.interval})
		self.nextRun = datetime.datetime.now() + self.period
		if self.startDay is not None:
			assert self.unit == 'weeks'
			weekdays = ('monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday')
			assert self.startDay in weekdays
			weekday = weekdays.index(self.startDay)
			days_ahead = weekday - self.nextRun.weekday()
			if days_ahead <= 0:  # Target day already happened this week
				days_ahead += 7
			self.nextRun += datetime.timedelta(days_ahead) - self.period
		if self.atTime is not None:
			assert self.unit in ('days', 'hours') or self.startDay is not None
			kwargs = { 'minute': self.atTime.minute, 'second': self.atTime.second, 'microsecond': 0 }
			if self.unit == 'days' or self.startDay is not None:
				kwargs['hour'] = self.atTime.hour
			self.nextRun = self.nextRun.replace(**kwargs)
			# If we are running for the first time, make sure we run at the specified time *today* (or *this hour*) as well
			if not self.lastRun:
				now = datetime.datetime.now()
				if self.unit == 'days' and self.atTime > now.time():
					self.nextRun = self.nextRun - datetime.timedelta(days=1)
				elif self.unit == 'hours' and self.atTime.minute > now.minute:
					self.nextRun = self.nextRun - datetime.timedelta(hours=1)
		if self.startDay is not None and self.atTime is not None:
			# Let's see if we will still make that time we specified today
			if (self.nextRun - datetime.datetime.now()).days >= 7:
				self.nextRun -= self.period
